# In Javascript, which scales better, insert() or append()? 

![summary of results](./results.png)  
> (above) Results of runtime analysis between doublerAppend() and doublerInsert().

When analyzing the runtime of insert() and append() given the same parameters, append() is the clear winner. The results indicate that on the first iteration, insert() is the faster of the two, but on subsequent iterations, insert() is slower. The scaling of insert() when given more workload is sub par when compared to append(), this is demonstrable once both methods encounter the 'largeArray' parameter. The runtime for doublerAppend(largeArray) is 418 microseconds while the runtime for the doublerInsert(largeArray) is 6 milliseconds, this pattern presents itself again once the methods encounter the extraLarge array where the difference between is 717 milliseconds. When dealing with the smallArray, the difference was 3 microseconds in favor of append(), not a huge difference and in fact insert() beat append() with the tinyArray. This demonstrates that under small workloads both methods perform similarly, but once the workload increases and the methods perform at scale, their run times become divergent.  

Why would these methods that achieve the same result perform differently at scale? The answer has to do with how each method operates under the hood. When append() encounters an array, it simply tacks an element onto the end, this is extremely fast on every iteration of the array except the first iteration. The reason for this is that in memory, the array has not been allocated enough space to grow yet. The first iteration of append has to request for the array to have extra space to grow, and then tack on an element, this takes a bit of time. What makes append() optimized is that once append() accesses an array, and has allocated extra space in memory for that array to grow, subsequent iterations of the append() method simply need to add an element to the end of the list in memory. The main bottleneck for append() is when it has to make a request for more memory to be allocated for an array (first time accessing an array).

The insert() method can perform the same function as append() by inserting an element at the end of an array, however, the way insert() works is by looking for a particular index. As the list of indices grows, insert() must look through that list until it finds the proper index. A bigger list of indices means more places to look and thus more time. If index() knew to jump to the very last element, this would not be the case and it would be faster at scale, at least when adding an element to the end of an array. The index() method is good at what it does and is optimized for searching a list quickly, the proof is there when dealing with the tinyArray when it beat append(). Both methods accel at different tasks and go about achieving their results by different methods. The index() method can, technically perform the same job as append(), but it is much better suited to inserting elements at a given location in a list, anywhere before the last element in the list will actually achieve quicker results  and the closer the index is to the beginning of the list, the quicker insert() finishes.

We've taken a look at two completely different methods performing a similar task, one of the methods was made for the task, the other method can perform it, but is mush slower going about it. The conclusion I present is to be sure the methods used in production code are appropriate for what the method is designed to do. Do not use insert() to concatenate an element on an array, Javascript has a special method just for that, append(). In addition to using appropriate methods, runtime analysis can present a software developer with an understanding of which functions are performant and how functions and methods compare when presented with a benchmark workload.
